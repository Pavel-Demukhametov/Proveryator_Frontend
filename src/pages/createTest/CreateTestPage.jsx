// src/pages/createTest/CreateTestPage.jsx

import React, { useState } from 'react';
import axios from 'axios';
import MiniLoadingSpinner from '../../components/loading/MiniLoadingSpinner';
import { useNavigate } from 'react-router-dom';
import CustomRadio from '../../components/сustomRadio/CustomRadio';
import CustomCheckbox from '../../components/сustomCheckbox/CustomCheckbox';
import { ToastContainer, toast } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

const CreateTestPage = () => {
  const [testTitle, setTestTitle] = useState(''); // Новое состояние для названия теста
  const [creationMethod, setCreationMethod] = useState('general'); // 'general' или 'byThemes'
  const [totalQuestions, setTotalQuestions] = useState('');
  const [themes, setThemes] = useState([
    {
      id: 1,
      title: '',
      description: `Классификация текста
Мы переходим к следующим этапам обработки текста, а именно анализ с помощью модели машинного обучения и постобработка
И начнем мы это делать с рассмотрения популярной задачи классификации текста
Мы уже рассматривали несколько примеров классификации текста
Одна из задач это определение тональности
Позитивная тональность в тексте или негативная
Другие примеры задач классификации текста — это определение так называемых fake news
Вот здесь примеры сообщений о реальной чрезвычайной ситуации или нет
Просто обычное сообщение
Также один из примеров — это определение токсичности текста
И еще один пример, который мы рассматривали – это определение депрессивных постов в социальных сетях
Давайте рассмотрим задачу классификации текста в общем виде
Она заключается в том, что у нас есть объект «Текст», и нужно определить, к какому классу относится есть объект, текст, и нужно определить, к какому классу относится этот объект
Причем классы заданы заранее, и они являются дискретными
          `,
      isIncluded: false,
      questionCount: 0,
    },
    {
      id: 8,
      title: '',
      description:       `То есть объект обязательно принадлежит как минимум одному, а может быть даже и нескольким классам
Какие могут быть классы? Например, в задаче фальшивых новостей класса 2
Реальная новость и фальшивая новость
В задаче определения тональности в общем случае классов может быть 3
Тональность в тексте позитивная, негативная или нейтральная
Для определения токсичности текста могут быть следующие классы
Текст является просто токсичным, в нем используется абсценная лексика, угрозы или оскорбления
Задача классификации с точки зрения машинного обучения – это задача обучения с учителем
Для того, чтобы ее решить, требуется размеченный набор данных с правильными ответами
      `,
      isIncluded: false,
      questionCount: '',
    },
    {
      id: 2,
      title: '',
      description: `Вот пример размеченного набора данных, который мы ранее рассматривали
Для анализа тональности отзывов на банке здесь указан текст, ну, точнее, фрагмент текста отзыва, и для каждого текста указана правильная тональность, позитивная или негативная
Такой правильный ответ вность, позитивная или негативная
Такой правильный ответ в размеченном наборе данных чаще всего называется метка класса
Ну и здесь метки класс записаны текстом позитив для позитивной тональности, негатив для негативной
Какие есть задачи классификации текстов? Чаще всего используются три постановки задачи`,
      isIncluded: false,
      questionCount: '',
    },
    {
      id: 3,
      title: '',
      description: `Первый – это бинарная классификация
В этом случае у нас есть два класса объектов, и объект может принадлежать только одному классу
Например, это положительная или отрицательная тональность текста
Второй вариант – многоклассовая классификация, по-английски «Multi-class classification»
В этом случае у нас есть несколько классов объектов
Например, мы классифицируем темы новостей на сайте, и таких тем, конечно, может быть не две, а гораздо больше
Вполне вероятно, что даже несколько десятков
Ограничение многоклассовой классификации заключается в том, что объект может принадлежать только одному классу
Если же наш объект может принадлежать нескольким классам, то это задача многозначной классификации
Multilabel classification
В этом случае у нас также несколько классов объектов, но нет ограничения, что объект принадлежит только одному классу, он может принадлежать сразу нескольким классам, в том числе и всем
И пример такой задачи это как раз классификация токсичных комментариев
Мы легко можем себе представить, что комментарий написан так, что в нем есть и угроза, и оскорбление, и все это матом
И таким образом, такой комментарий относится сразу к нескольким классам
В зависимости от того, какую задачу классификации мы решаем, нам нужно по-разному строить модели машинного обучения и использовать разные функции ошибки
Мы научились определять класс текста для объектов, теперь нам нужно понять, а насколько качественно работает наша модель
Здесь очень важным является шаг разделения нашего набора данных на обучающий и тестовый
И оценивать качество работы обученной модели можно только на тестовом наборе данных
В противном случае мы можем получить переобучение, когда у модели низкая обобщающая способность от английского Generalization, и она хорошо работает только с теми данными, на которых обучалась, а с новыми данными будет работать плохо
Поэтому оценивать качество работы модели можно только на тех данных, которые она не видела в процессе обучения
В противном случае мы не можем сделать никаких выводов об обобщающей способности модели
Как же конкретно мы будем оценивать те качества работы классификации? Для этого есть несколько метрик`,
      isIncluded: false,
      questionCount: '',
    },
    {
      id: 4,
      title: '',
      description: `Самая простая метрика — это доля правильных ответов, accuracy
Она показывает долю, в которой решение модели было правильным и метка класса для объекта определена правильно
Эта метрика хорошо подходит только для тех случаев, когда у вас количество элементов в каждом классе примерно одинаковое
А если же у вас элементов какого-то класса значительно меньше, чем другого класса или других классов, то метрика Accuracy уже работает плохо
Вместо нее используют более сложные методы, которые пришли из информационного поиска
Это точность, по-английски precision
Эта метрика говорит о том, насколько часто наша модель ошибается и назначает метку интересующего нас класса объектам других классов
Метрика полнота, от английский recall, показывает, насколько полно находятся объекты нужного нам класса
Это доля правильно классифицированных объектов нужного нам класса по сравнению с общим количеством объектов этого класса
Ну и для тех случаев, когда нам нужно учитывать не только точность или полноту отдельно, мы можем использовать f-меру
Это гармоническое среднее точности и полноты
Итак, мы рассмотрели постановку задачи классификации текста
Она заключается в том, что нам нужно определить, к какому классу относится объект, в нашем случае текст
При этом классы нам заданы заранее
С точки зрения машинного обучения, классификация текста – это задача обучения с учителем
Для того, чтобы ее решать, необходим размеченный набор данных с правильными ответами
И именно на таком размеченном наборе данных мы и будем производить обучение нашей модели
Есть три типа задач классификации
Бинарная классификация, многоклассовая классификация и многозначная классификация
И в зависимости от того, какой тип задачи классификации решается, модель машинного обучения строится немного по-разному и используются разные функции ошибки и метрики оценки качества
Для того, чтобы решать задачи классификации текста, можно использовать как классические алгоритмы машинного обучения, такие как логистическая регрессия, байсовский классификатор, случайный лес и другие подобные алгоритмы, а также нейронные сети
В этом разделе мы рассмотрим, как использовать классические алгоритмы, которые до сих пор на простых задачах показывают хорошие результаты, при этом обучаются и работают гораздо быстрее, чем нейронные сети
А применение нейронных сетей для классификации текста мы рассмотрим в следующем разделе
Нейронные сети для обработки текста
До сих пор мы рассматривали текст как множество слов
При этом результаты анализа текста зависят только от того, какие слова в него входят, и порядок слов не имеет значения
Пример задачи, для которой хорошо работает такой подход, это определение тональности текста
Мы решали задачу определения тональности для отзывов на банки
И как мы могли убедиться, даже такие простые модели, как мешок слов и логистическая регрессия, хорошо работают для такой задачи`,
      isIncluded: false,
      questionCount: '',
    },
    {
      id: 5,
      title: '',
      description: `Напомню, что мешок слов содержит информацию о том, какие слова и сколько раз встречаются в тексте
Но при составлении мешка слов теряется информация о порядке слов
Однако для задачи определения тональности, а также для некоторых задач классификации текста, такого подхода вполне достаточно
Далее в курсе мы будем переходить к решению более сложных задач, такие как генерация текста
Также простого подхода на основе анализа текста как множество слов недостаточно, например, для решения задачи автоматического перевода и многих других более сложных задач анализа и обработки текстов
Почему так происходит? Потому что на самом деле в тексте имеет смысл порядок слов, ну или символов
И для того, чтобы учитывать порядок слов, нам необходимо использовать более сложные алгоритмы
Из машинного обучения это нейронные сети и, конечно же, плотные векторные представления слов, которые мы рассмотрели в предыдущих разделах курса
Почему эффективно анализировать имена текст как последовательность? Давайте рассмотрим несколько примеров`,
      isIncluded: false,
      questionCount: '',
    },
    {
      id: 6,
      title: '',
      description: `Когда мы анализируем тексты для определения тональности и прочитаем, например, такой текст «Мобильное приложение банка неудобное»
Мы можем увидеть слово «удобное» и подумать, что отзыв положительный
Но однако же, если мы проанализируем словосочетание «неудобное», то, скорее всего, отзыв, как минимум, нейтральный, а, наверное, даже отрицательный
При этом слова, которые влияют на результат анализа, могут находиться не рядом друг с другом, как вот в этом предложении, неудобное, а на некотором расстоянии
Например, в целом банк не такой уж и плохой
Если бы мы просто рассмотрели слово «плохой», то подумали бы, что отзыв отрицательный
Но утверждение не такое уж и плохой говорит нам о том, что банк скорее всего хороший
То есть тональность этого текста либо нейтральная, либо положительная`,
      isIncluded: false,
      questionCount: '',
    },
    {
      id: 7,
      title: '',
      description: `А в русском языке морская свинка, которая, как известно, совсем не свинка и совсем не морская
В этом разделе курса мы подробно рассмотрим, как использовать нейронные сети для анализа текстов
Именно нейронные сети для анализа текстов
Именно нейронные сети могут анализировать текст как последовательность символов
Мы рассмотрим, какие именно архитектуры нейронных сетей подходят для этой задачи анализа текста как последовательности символов или слов
Это рекуррентные нейронные сети, такие как LSTM и GRU, одномерные сверточные нейронные сети и современный подход нейронной сети с архитектурой Transformer
В этом разделе курса мы предполагаем, что вы уже умеете разрабатывать программы на Python для нейронных сетей в TensorFlow и Keras
Если вы не знаете, как это делать, то рекомендуется предварительно пройти курсы по данной тематике
`.trimStart(),
      isIncluded: false,
      questionCount: '',
    },
    // Добавьте больше тем по необходимости
  ]);
  const [loading, setLoading] = useState(false);
  const [lectureText] = useState('Классификация текста. Мы переходим к следующим этапам обработки текста, а именно анализ с помощью модели машинного обучения и постобработка. И начнем мы это делать с рассмотрения популярной задачи классификации текста. Мы уже рассматривали несколько примеров классификации текста. Одна из задач это определение тональности. Позитивная тональность в тексте или негативная. Другие примеры задач классификации текста — это определение так называемых fake news. Вот здесь примеры сообщений о реальной чрезвычайной ситуации или нет. Просто обычное сообщение. Также один из примеров — это определение токсичности текста. И еще один пример, который мы рассматривали – это определение депрессивных постов в социальных сетях. Давайте рассмотрим задачу классификации текста в общем виде. Она заключается в том, что у нас есть объект «Текст», и нужно определить, к какому классу относится есть объект, текст, и нужно определить, к какому классу относится этот объект. Причем классы заданы заранее, и они являются дискретными. То есть объект обязательно принадлежит как минимум одному, а может быть даже и нескольким классам. Какие могут быть классы? Например, в задаче фальшивых новостей класса 2. Реальная новость и фальшивая новость. В задаче определения тональности в общем случае классов может быть 3. Тональность в тексте позитивная, негативная или нейтральная. Для определения токсичности текста могут быть следующие классы. Текст является просто токсичным, в нем используется абсценная лексика, угрозы или оскорбления. Задача классификации с точки зрения машинного обучения – это задача обучения с учителем. Для того, чтобы ее решить, требуется размеченный набор данных с правильными ответами. Вот пример размеченного набора данных, который мы ранее рассматривали. Для анализа тональности отзывов на банке здесь указан текст, ну, точнее, фрагмент текста отзыва, и для каждого текста указана правильная тональность, позитивная или негативная. Такой правильный ответ вность, позитивная или негативная. Такой правильный ответ в размеченном наборе данных чаще всего называется метка класса. Ну и здесь метки класс записаны текстом позитив для позитивной тональности, негатив для негативной. Какие есть задачи классификации текстов? Чаще всего используются три постановки задачи. Первый – это бинарная классификация. В этом случае у нас есть два класса объектов, и объект может принадлежать только одному классу. Например, это положительная или отрицательная тональность текста. Второй вариант – многоклассовая классификация, по-английски «Multi-class classification». В этом случае у нас есть несколько классов объектов. Например, мы классифицируем темы новостей на сайте, и таких тем, конечно, может быть не две, а гораздо больше. Вполне вероятно, что даже несколько десятков. Ограничение многоклассовой классификации заключается в том, что объект может принадлежать только одному классу. Если же наш объект может принадлежать нескольким классам, то это задача многозначной классификации. Multilabel classification. В этом случае у нас также несколько классов объектов, но нет ограничения, что объект принадлежит только одному классу, он может принадлежать сразу нескольким классам, в том числе и всем. И пример такой задачи это как раз классификация токсичных комментариев. Мы легко можем себе представить, что комментарий написан так, что в нем есть и угроза, и оскорбление, и все это матом. И таким образом, такой комментарий относится сразу к нескольким классам. В зависимости от того, какую задачу классификации мы решаем, нам нужно по-разному строить модели машинного обучения и использовать разные функции ошибки. Мы научились определять класс текста для объектов, теперь нам нужно понять, а насколько качественно работает наша модель. Здесь очень важным является шаг разделения нашего набора данных на обучающий и тестовый. И оценивать качество работы обученной модели можно только на тестовом наборе данных. В противном случае мы можем получить переобучение, когда у модели низкая обобщающая способность от английского Generalization, и она хорошо работает только с теми данными, на которых обучалась, а с новыми данными будет работать плохо. Поэтому оценивать качество работы модели можно только на тех данных, которые она не видела в процессе обучения. В противном случае мы не можем сделать никаких выводов об обобщающей способности модели. Как же конкретно мы будем оценивать те качества работы классификации? Для этого есть несколько метрик. Самая простая метрика — это доля правильных ответов, accuracy. Она показывает долю, в которой решение модели было правильным и метка класса для объекта определена правильно. Эта метрика хорошо подходит только для тех случаев, когда у вас количество элементов в каждом классе примерно одинаковое. А если же у вас элементов какого-то класса значительно меньше, чем другого класса или других классов, то метрика Accuracy уже работает плохо. Вместо нее используют более сложные методы, которые пришли из информационного поиска. Это точность, по-английски precision. Эта метрика говорит о том, насколько часто наша модель ошибается и назначает метку интересующего нас класса объектам других классов. Метрика полнота, от английский recall, показывает, насколько полно находятся объекты нужного нам класса. Это доля правильно классифицированных объектов нужного нам класса по сравнению с общим количеством объектов этого класса. Ну и для тех случаев, когда нам нужно учитывать не только точность или полноту отдельно, мы можем использовать f-меру. Это гармоническое среднее точности и полноты. Итак, мы рассмотрели постановку задачи классификации текста. Она заключается в том, что нам нужно определить, к какому классу относится объект, в нашем случае текст. При этом классы нам заданы заранее. С точки зрения машинного обучения, классификация текста – это задача обучения с учителем. Для того, чтобы ее решать, необходим размеченный набор данных с правильными ответами. И именно на таком размеченном наборе данных мы и будем производить обучение нашей модели. Есть три типа задач классификации. Бинарная классификация, многоклассовая классификация и многозначная классификация. И в зависимости от того, какой тип задачи классификации решается, модель машинного обучения строится немного по-разному и используются разные функции ошибки и метрики оценки качества. Для того, чтобы решать задачи классификации текста, можно использовать как классические алгоритмы машинного обучения, такие как логистическая регрессия, байсовский классификатор, случайный лес и другие подобные алгоритмы, а также нейронные сети. В этом разделе мы рассмотрим, как использовать классические алгоритмы, которые до сих пор на простых задачах показывают хорошие результаты, при этом обучаются и работают гораздо быстрее, чем нейронные сети. А применение нейронных сетей для классификации текста мы рассмотрим в следующем разделе. Нейронные сети для обработки текста. До сих пор мы рассматривали текст как множество слов. При этом результаты анализа текста зависят только от того, какие слова в него входят, и порядок слов не имеет значения. Пример задачи, для которой хорошо работает такой подход, это определение тональности текста. Мы решали задачу определения тональности для отзывов на банки. И как мы могли убедиться, даже такие простые модели, как мешок слов и логистическая регрессия, хорошо работают для такой задачи. Напомню, что мешок слов содержит информацию о том, какие слова и сколько раз встречаются в тексте. Но при составлении мешка слов теряется информация о порядке слов. Однако для задачи определения тональности, а также для некоторых задач классификации текста, такого подхода вполне достаточно. Далее в курсе мы будем переходить к решению более сложных задач, такие как генерация текста. Также простого подхода на основе анализа текста как множество слов недостаточно, например, для решения задачи автоматического перевода и многих других более сложных задач анализа и обработки текстов. Почему так происходит? Потому что на самом деле в тексте имеет смысл порядок слов, ну или символов. И для того, чтобы учитывать порядок слов, нам необходимо использовать более сложные алгоритмы. Из машинного обучения это нейронные сети и, конечно же, плотные векторные представления слов, которые мы рассмотрели в предыдущих разделах курса. Почему эффективно анализировать имена текст как последовательность? Давайте рассмотрим несколько примеров. Когда мы анализируем тексты для определения тональности и прочитаем, например, такой текст «Мобильное приложение банка неудобное». Мы можем увидеть слово «удобное» и подумать, что отзыв положительный. Но однако же, если мы проанализируем словосочетание «неудобное», то, скорее всего, отзыв, как минимум, нейтральный, а, наверное, даже отрицательный. При этом слова, которые влияют на результат анализа, могут находиться не рядом друг с другом, как вот в этом предложении, неудобное, а на некотором расстоянии. Например, в целом банк не такой уж и плохой. Если бы мы просто рассмотрели слово «плохой», то подумали бы, что отзыв отрицательный. Но утверждение не такое уж и плохой говорит нам о том, что банк скорее всего хороший. То есть тональность этого текста либо нейтральная, либо положительная. Ну и конечно же есть словосочетания, которые меняют значение. Например, в английском ice cream – это мороженое, в то время как ice – это лед, а cream – это крем или сливки. А в русском языке морская свинка, которая, как известно, совсем не свинка и совсем не морская. В этом разделе курса мы подробно рассмотрим, как использовать нейронные сети для анализа текстов. Именно нейронные сети для анализа текстов. Именно нейронные сети могут анализировать текст как последовательность символов. Мы рассмотрим, какие именно архитектуры нейронных сетей подходят для этой задачи анализа текста как последовательности символов или слов. Это рекуррентные нейронные сети, такие как LSTM и GRU, одномерные сверточные нейронные сети и современный подход нейронной сети с архитектурой Transformer. В этом разделе курса мы предполагаем, что вы уже умеете разрабатывать программы на Python для нейронных сетей в TensorFlow и Keras. Если вы не знаете, как это делать, то рекомендуется предварительно пройти курсы по данной тематике.'); // Текст лекции, нельзя менять
  const navigate = useNavigate();

  const handleCreationMethodChange = (e) => {
    setCreationMethod(e.target.value);
    // Сбросить значения при смене метода
    setTotalQuestions('');
    setThemes((prevThemes) =>
      prevThemes.map((theme) => ({
        ...theme,
        isIncluded: false,
        questionCount: '',
      }))
    );
  };

  const handleThemeToggle = (id) => {
    setThemes((prevThemes) =>
      prevThemes.map((theme) =>
        theme.id === id
          ? { ...theme, isIncluded: !theme.isIncluded, questionCount: theme.isIncluded ? '' : theme.questionCount }
          : theme
      )
    );
  };

  const handleThemeQuestionCountChange = (id, count) => {
    // Позволяем вводить только числа больше 0
    if (count === '' || (/^\d+$/.test(count) && parseInt(count, 10) > 0)) {
      setThemes((prevThemes) =>
        prevThemes.map((theme) =>
          theme.id === id ? { ...theme, questionCount: count } : theme
        )
      );
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    // Валидация
    if (!testTitle.trim()) {
      toast.error('Пожалуйста, введите название теста.');
      return;
    }

    if (creationMethod === 'general') {
      if (!totalQuestions || isNaN(totalQuestions) || parseInt(totalQuestions, 10) <= 0) {
        toast.error('Пожалуйста, введите корректное количество вопросов (больше 0).');
        return;
      }
    } else if (creationMethod === 'byThemes') {
      const selectedThemes = themes.filter((theme) => theme.isIncluded);
      if (selectedThemes.length === 0) {
        toast.error('Пожалуйста, выберите хотя бы одну тему.');
        return;
      }
      for (let theme of selectedThemes) {
        if (!theme.questionCount || isNaN(theme.questionCount) || parseInt(theme.questionCount, 10) <= 0) {
          toast.error(`Пожалуйста, введите корректное количество вопросов для темы "${theme.title}" (больше 0).`);
          return;
        }
      }
    }

    setLoading(true);

    try {
      const headers = {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('accessToken')}`,
      };

      const payload = {
        lectureText,
        method: creationMethod,
        title: testTitle, // Добавляем название теста в payload
      };

      if (creationMethod === 'general') {
        payload.totalQuestions = parseInt(totalQuestions, 10);
      } else if (creationMethod === 'byThemes') {
        payload.themes = themes
          .filter((theme) => theme.isIncluded)
          .map((theme) => ({
            id: theme.id,
            questionCount: parseInt(theme.questionCount, 10),
          }));
      }

      // Раскомментируйте строку ниже после настройки бэкенда
      // const response = await axios.post('http://127.0.0.1:8000/api/tests/create/', payload, { headers });

      // Для демонстрации перенаправления после успешной загрузки
      toast.success('Тест успешно создан!');
      setTimeout(() => {
        navigate('/test/1'); // Перенаправление на страницу со списком тестов
      }, 1500);
    } catch (error) {
      console.error('Ошибка при создании теста:', error);
      toast.error('Не удалось создать тест. Пожалуйста, попробуйте снова.');
    } finally {
      setLoading(false);
    }
  };

  // Функция для получения подсказки на основе метода создания
  const getHintText = () => {
    if (creationMethod === 'general') {
      return 'Автоматически создадутся выбранное количество вопросов по всей лекции.';
    } else if (creationMethod === 'byThemes') {
      return 'Автоматически из лекции разбиваются на сегменты. Вы можете выбрать, какие сегменты использовать в тесте.';
    }
    return '';
  };

  return (
    <div className="max-w-3xl mx-auto p-6 bg-white dark:bg-gray-800 rounded-md shadow-md mt-10">
      <h1 className="text-3xl font-bold mb-6 text-center text-gray-800 dark:text-gray-200">Создание теста</h1>
      <form onSubmit={handleSubmit}>
        {/* Поле для ввода названия теста */}
        <div className="mb-6">
          <label htmlFor="testTitle" className="block text-gray-700 dark:text-gray-200 font-medium mb-2">
            Название теста:
          </label>
          <input
            type="text"
            id="testTitle"
            name="testTitle"
            className="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white"
            placeholder="Введите название теста"
            value={testTitle}
            onChange={(e) => setTestTitle(e.target.value)}
            required
          />
        </div>

        {/* Выбор метода создания теста */}
        <div className="mb-6">
          <label className="block text-gray-700 dark:text-gray-200 font-medium mb-2">
            Метод создания теста:
          </label>
          <div className="flex items-center space-x-4">
            <label className="inline-flex items-center">
              <input
                type="radio"
                className="form-radio h-5 w-5 text-blue-600 dark:text-blue-400"
                value="general"
                checked={creationMethod === 'general'}
                onChange={handleCreationMethodChange}
              />
              <span className="ml-2 text-gray-800 dark:text-gray-200">По общему количеству вопросов</span>
            </label>
            <label className="inline-flex items-center">
              <input
                type="radio"
                className="form-radio h-5 w-5 text-blue-600 dark:text-blue-400"
                value="byThemes"
                checked={creationMethod === 'byThemes'}
                onChange={handleCreationMethodChange}
              />
              <span className="ml-2 text-gray-800 dark:text-gray-200">По выбранным темам</span>
            </label>
          </div>
          <p className="mt-2 text-sm text-gray-600 dark:text-gray-400">
            {getHintText()}
          </p>
        </div>

        {/* Многострочный текст лекции */}
        <div className="mb-6">
          <label className="block text-gray-700 dark:text-gray-200 font-medium mb-2">
            Текст лекции:
          </label>
          <textarea
          className="w-full h-96 px-4 py-2 border rounded-md bg-gray-100 dark:bg-gray-700 dark:border-gray-600 dark:text-white cursor-not-allowed"
          value={lectureText}
          readOnly
        ></textarea>
        </div>

        {/* Форма для общего количества вопросов */}
        {creationMethod === 'general' && (
          <div className="mb-6">
            <label htmlFor="totalQuestions" className="block text-gray-700 dark:text-gray-200 font-medium mb-2">
              Вопросы с одним правильным ответом:
            </label>
            <input
              type="number"
              id="totalQuestions"
              name="totalQuestions"
              className="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white"
              placeholder="Введите количество вопросов"
              value={totalQuestions}
              onChange={(e) => {
                const value = e.target.value;
                // Позволяем вводить только числа больше 0
                if (value === '' || (/^\d+$/.test(value) && parseInt(value, 10) > 0)) {
                  setTotalQuestions(value);
                }
              }}
              min="1"
              step="1"
              required
            />
            <label htmlFor="totalQuestions" className="block text-gray-700 dark:text-gray-200 font-medium mb-2">
              Вопросы с открытым ответом:
            </label>
            <input
              type="number"
              id="totalQuestions"
              name="totalQuestions"
              className="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white"
              placeholder="Введите количество вопросов"
              value={totalQuestions}
              onChange={(e) => {
                const value = e.target.value;
                // Позволяем вводить только числа больше 0
                if (value === '' || (/^\d+$/.test(value) && parseInt(value, 10) > 0)) {
                  setTotalQuestions(value);
                }
              }}
              min="1"
              step="1"
              required
            />
          </div>
          
        )}

        {/* Форма для выбора тем */}
        {creationMethod === 'byThemes' && (
          <div className="mb-6">
            <label className="block text-gray-700 dark:text-gray-200 font-medium mb-2">
              Выберите сегменты для теста:
            </label>
            <div className="space-y-4">
              {themes.map((theme) => (
                <div key={theme.id} className="p-4 border rounded-md dark:border-gray-600 bg-gray-50 dark:bg-gray-700 w-full">
                  <div className="flex flex-col w-full justify-between">
                    <div className="w-full">
                      <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200">{theme.title}</h3>
                      
                      {/* Многострочное поле для описания */}
                      <textarea
                        className="w-full px-4 py-2 mt-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white"
                        rows="5"
                        value={theme.description}
                        readOnly
                      ></textarea>
                    </div>
                    <div className="mt-4 w-full">
                      <CustomCheckbox
                        id={`theme-${theme.id}`}
                        checked={theme.isIncluded}
                        onChange={() => handleThemeToggle(theme.id)}
                        label="Включить"
                      />
                    </div>
                  </div>
                  {theme.isIncluded && (
                    <div className="mt-4 w-full">
                      <label htmlFor={`questionCount-${theme.id}`} className="block text-gray-700 dark:text-gray-200 font-medium mb-2">
                        Количество вопросов с одним правильным ответом для этой темы:
                      </label>
                      <input
                        type="number"
                        id={`questionCount-${theme.id}`}
                        name={`questionCount-${theme.id}`}
                        className="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white"
                        placeholder="Введите количество вопросов"
                        value={theme.questionCount}
                        onChange={(e) => handleThemeQuestionCountChange(theme.id, e.target.value)}
                        min="1"
                        step="1"
                        required
                      />
                      <label htmlFor={`questionCount-${theme.id}`} className="block text-gray-700 dark:text-gray-200 font-medium mb-2">
                        Количество вопросов с открытым ответом для этой темы:
                      </label>
                      <input
                        type="number"
                        id={`questionCount-${theme.id}`}
                        name={`questionCount-${theme.id}`}
                        className="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white"
                        placeholder="Введите количество вопросов"
                        value={theme.questionCount}
                        onChange={(e) => handleThemeQuestionCountChange(theme.id, e.target.value)}
                        min="1"
                        step="1"
                        required
                      />
                    </div>
                  )}
                </div>
              ))}
            </div>
          </div>
        )}
        {/* Кнопка создания теста */}
        <div className="flex justify-center">
          {loading ? (
            <MiniLoadingSpinner />
          ) : (
            <button
              type="submit"
              className="w-full px-4 py-2 bg-blue-600 dark:bg-blue-500 text-white font-semibold rounded-md hover:bg-blue-700 dark:hover:bg-blue-600 transition duration-300 focus:outline-none focus:ring-2 focus:ring-blue-400"
            >
              Создать тест
            </button>
          )}
        </div>
      </form>

      {/* Контейнер для уведомлений */}
      <ToastContainer position="top-right" autoClose={3000} hideProgressBar newestOnTop closeOnClick rtl={false} pauseOnFocusLoss draggable pauseOnHover />
    </div>
  );
};

export default CreateTestPage;